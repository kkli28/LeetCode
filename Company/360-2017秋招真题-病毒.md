> Description

小B最近对破解和程序攻击产生了兴趣，她迷上了病毒，然后可怕的事情就发生了。不知道什么原因，可能是小B的技术水平还不够高，小B编写的病毒程序在攻击一个服务器时出现了问题。尽管成功的侵入了服务器，但并没有按照期望的方式发挥作用。

小B的目的很简单:控制服务器的内存区域，试图在内存中装入从1到n之间的n个自然数，以覆盖内存区域。可能是小B对编程理解上的问题，病毒似乎没有完全成功。可能是由于保护机制的原因，内存写入只接受二进制的形式，所以十进制表达中除0和1之外的其他值都没有成功写入内存。小B希望知道，究竟有多少数成功的写入了服务器的内存！

```
样例输入:
10
20

样例输出:
2
3

//解释：0~10有两个类似二进制，即1和10。1~20有1、10、11三个
```

> 思路

只统计形式为二进制的十进制数，因此如1、10、11、100、101等才会统计。需要先找出统计规律。

```
1~9:            1
10~99:          10 11
100~999:        100 101 110 111
1000~9999:      1000 1001 1010 1011 1100 1101 1110 1111
```

由上面的规律可知，数字的位数减1，作用于2的幂，就是该范围内形如二进制的数的个数。即
`1~9`，1位数，`2^0=1`。`10~100`，2位数，`2^1=2`。`1000~9999`，4位数，`2^3=8`。

加入输入的数字是四位数`1234`，则可统计得 `1+2+4+8=15`。但是如果是 `1010`呢？

因此统计时，若该数字属于上述的第n行（有n位数），则先统计前 `n-1` 行，第n行特殊处理即可。

例如输入 `1010`，4位数，则先统计前3行，得 `1+2+4=7`。第4行可通过找规律来处理。

第四行的规律为：前4个第2位为0，后4个第2位为1。若第2位大于1，则第4行可全部统计，即结果加8。
如果等于1，则前4个属于统计范畴，需要再判断后4个中哪些符合条件（再判断第3位）。如果小于1，
则后4个不属于统计范畴，需要再判断前4个。

简化规律: 下标从1开始，用temp保存第4行元素个数。若n[2]>1，result+=temp。若n[2]<1，即n[2]==0，
temp=temp-temp/2。依次类推，直到最后一个位判断完。

> Solution

```C++
#include<iostream>
using namespace std;

//计算x^y
int pow(int x, int y) {
	int temp = 1;
	for (int i = 0; i < y; ++i)
		temp *= x;
	return temp;
}

int main() {
	int input = 0;
	while (cin >> input) {
		int result = 0;             //统计结果
		int pw = 0;                 //第n行有2的pw次方个元素
		int temp = input;           //避免破坏input

        //统计位数
		while (temp > 0) {
			++pw;
			temp /= 10;
		}
		--pw;                   //pw行有2^(pw-1)个元素，对pw减1后，方便直接使用2^pw

        //统计前pw行（注意，pw已减1，总共有pw+1行）
		for (int i = 0; i < pw; ++i) result += pow(2, i);

        //第pw+1行的元素个数
		temp = pow(2, pw);

        //判断输入数字的从第2位到最后一位
		while (pw > 0) {
			int ten = pow(10, pw);
			if (input / ten > 1) break;         //遇到大于1的数，则必然包含1xx或0xx
			input %= ten;
			--pw;

			int tmp = input;
			int len = 0;
			while (tmp > 0) {
				++len;
				tmp /= 10;
			}

            //0，则丢弃当前位数对应的二进制幂的一半个数
			if (len <= pw) temp -= pow(2, pw);
		}

        //前pw行统计结果加上第pw+1行的统计结果
		cout << result + temp << endl;
	}
	return 0;
}
```